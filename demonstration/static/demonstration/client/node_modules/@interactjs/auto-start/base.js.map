{
	"version": 3,
	"sources": [
		"base.ts"
	],
	"names": [
		"utils",
		"InteractableMethods",
		"install",
		"scope",
		"interact",
		"defaults",
		"usePlugin",
		"base",
		"actionChecker",
		"styleCursor",
		"extend",
		"perAction",
		"manualStart",
		"max",
		"Infinity",
		"maxPerElement",
		"allowFrom",
		"ignoreFrom",
		"mouseButtons",
		"maxInteractions",
		"newValue",
		"autoStart",
		"withinInteractionLimit",
		"cursorElement",
		"prepareOnDown",
		"interaction",
		"pointer",
		"event",
		"eventTarget",
		"interacting",
		"actionInfo",
		"getActionInfo",
		"prepare",
		"prepareOnMove",
		"pointerType",
		"pointerIsDown",
		"startOnMove",
		"arg",
		"pointerWasMoved",
		"prepared",
		"name",
		"fire",
		"interactable",
		"options",
		"element",
		"stop",
		"start",
		"setInteractionCursor",
		"clearCursorOnStop",
		"setCursor",
		"validateAction",
		"action",
		"testIgnoreAllow",
		"enabled",
		"validateMatches",
		"matches",
		"matchElements",
		"i",
		"len",
		"length",
		"match",
		"matchElement",
		"matchAction",
		"getAction",
		"pushMatches",
		"push",
		"is",
		"interactables",
		"forEachMatch",
		"dom",
		"parentNode",
		"copyAction",
		"rect",
		"getRect",
		"maxActions",
		"autoStartMax",
		"activeInteractions",
		"interactableCount",
		"elementCount",
		"interactions",
		"list",
		"otherAction",
		"number",
		"cursor",
		"style",
		"ownerDocument",
		"documentElement",
		"cursorChecker",
		"func",
		"_interacting",
		"actions",
		"getCursor",
		"id",
		"listeners",
		"before"
	],
	"mappings": "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",
	"sourcesContent": [
		"import * as utils from '../utils/index'\nimport InteractableMethods from './InteractableMethods'\n\ndeclare module '@interactjs/interact/interact' {\n  interface InteractStatic {\n    maxInteractions: (newValue: any) => any\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface Scope {\n    autoStart: AutoStart\n    maxInteractions: (...args: any) => any\n  }\n}\n\ndeclare module '@interactjs/core/defaultOptions' {\n  interface BaseDefaults {\n    actionChecker?\n    styleCursor?\n  }\n\n  interface PerActionDefaults {\n    manualStart?: boolean\n    max?: number\n    maxPerElement?: number\n    allowFrom?: string | Interact.Element\n    ignoreFrom?: string | Interact.Element\n\n    // only allow left button by default\n    // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\n    mouseButtons?: 0 | 1 | 2 | 4 | 16\n  }\n}\n\ndeclare module '@interactjs/core/scope' {\n  interface SignalArgs {\n    'autoStart:before-start': Interact.SignalArgs['interactions:move']\n    'autoStart:prepared': { interaction: Interact.Interaction }\n  }\n}\n\nexport interface AutoStart {\n  // Allow this many interactions to happen simultaneously\n  maxInteractions: number\n  withinInteractionLimit: typeof withinInteractionLimit\n  cursorElement: Interact.Element\n}\n\nfunction install (scope: Interact.Scope) {\n  const {\n    interact,\n    defaults,\n  } = scope\n\n  scope.usePlugin(InteractableMethods)\n\n  defaults.base.actionChecker = null\n  defaults.base.styleCursor = true\n\n  utils.extend(defaults.perAction, {\n    manualStart: false,\n    max: Infinity,\n    maxPerElement: 1,\n    allowFrom:  null,\n    ignoreFrom: null,\n\n    // only allow left button by default\n    // see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons#Return_value\n    mouseButtons: 1,\n  })\n\n  /**\n   * Returns or sets the maximum number of concurrent interactions allowed.  By\n   * default only 1 interaction is allowed at a time (for backwards\n   * compatibility). To allow multiple interactions on the same Interactables and\n   * elements, you need to enable it in the draggable, resizable and gesturable\n   * `'max'` and `'maxPerElement'` options.\n   *\n   * @alias module:interact.maxInteractions\n   *\n   * @param {number} [newValue] Any number. newValue <= 0 means no interactions.\n   */\n  interact.maxInteractions = newValue => maxInteractions(newValue, scope)\n\n  scope.autoStart = {\n    // Allow this many interactions to happen simultaneously\n    maxInteractions: Infinity,\n    withinInteractionLimit,\n    cursorElement: null,\n  }\n}\n\nfunction prepareOnDown ({ interaction, pointer, event, eventTarget }: Interact.SignalArgs['interactions:down'], scope: Interact.Scope) {\n  if (interaction.interacting()) { return }\n\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget, scope)\n  prepare(interaction, actionInfo, scope)\n}\n\nfunction prepareOnMove ({ interaction, pointer, event, eventTarget }: Interact.SignalArgs['interactions:move'], scope: Interact.Scope) {\n  if (interaction.pointerType !== 'mouse' ||\n      interaction.pointerIsDown ||\n      interaction.interacting()) { return }\n\n  const actionInfo = getActionInfo(interaction, pointer, event, eventTarget as Interact.Element, scope)\n  prepare(interaction, actionInfo, scope)\n}\n\nfunction startOnMove (arg: Interact.SignalArgs['interactions:move'], scope: Interact.Scope) {\n  const { interaction } = arg\n\n  if (!interaction.pointerIsDown ||\n      interaction.interacting() ||\n      !interaction.pointerWasMoved ||\n      !interaction.prepared.name) {\n    return\n  }\n\n  scope.fire('autoStart:before-start', arg)\n\n  const { interactable } = interaction\n\n  if (interaction.prepared.name && interactable) {\n    // check manualStart and interaction limit\n    if (interactable.options[interaction.prepared.name].manualStart ||\n        !withinInteractionLimit(interactable, interaction.element, interaction.prepared, scope)) {\n      interaction.stop()\n    }\n    else {\n      interaction.start(interaction.prepared, interactable, interaction.element)\n      setInteractionCursor(interaction, scope)\n    }\n  }\n}\n\nfunction clearCursorOnStop ({ interaction }: { interaction: Interact.Interaction }, scope: Interact.Scope) {\n  const { interactable } = interaction\n\n  if (interactable && interactable.options.styleCursor) {\n    setCursor(interaction.element, '', scope)\n  }\n}\n\n// Check if the current interactable supports the action.\n// If so, return the validated action. Otherwise, return null\nfunction validateAction (\n  action: Interact.ActionProps,\n  interactable: Interact.Interactable,\n  element: Interact.Element,\n  eventTarget: Interact.EventTarget,\n  scope: Interact.Scope,\n) {\n  if (interactable.testIgnoreAllow(interactable.options[action.name], element, eventTarget) &&\n      interactable.options[action.name].enabled &&\n      withinInteractionLimit(interactable, element, action, scope)) {\n    return action\n  }\n\n  return null\n}\n\nfunction validateMatches (\n  interaction: Interact.Interaction,\n  pointer,\n  event,\n  matches: Interact.Interactable[],\n  matchElements: Interact.Element[],\n  eventTarget: Interact.EventTarget,\n  scope: Interact.Scope,\n) {\n  for (let i = 0, len = matches.length; i < len; i++) {\n    const match = matches[i]\n    const matchElement = matchElements[i]\n    const matchAction = match.getAction(pointer, event, interaction, matchElement)\n\n    if (!matchAction) { continue }\n\n    const action = validateAction(\n      matchAction,\n      match,\n      matchElement,\n      eventTarget,\n      scope)\n\n    if (action) {\n      return {\n        action,\n        interactable: match,\n        element: matchElement,\n      }\n    }\n  }\n\n  return { action: null, interactable: null, element: null }\n}\n\nfunction getActionInfo (\n  interaction: Interact.Interaction,\n  pointer: Interact.PointerType,\n  event: Interact.PointerEventType,\n  eventTarget: Interact.EventTarget,\n  scope: Interact.Scope,\n) {\n  let matches = []\n  let matchElements = []\n\n  let element = eventTarget\n\n  function pushMatches (interactable) {\n    matches.push(interactable)\n    matchElements.push(element)\n  }\n\n  while (utils.is.element(element)) {\n    matches = []\n    matchElements = []\n\n    scope.interactables.forEachMatch(element, pushMatches)\n\n    const actionInfo = validateMatches(interaction, pointer, event, matches, matchElements, eventTarget, scope)\n\n    if (actionInfo.action &&\n      !actionInfo.interactable.options[actionInfo.action.name].manualStart) {\n      return actionInfo\n    }\n\n    element = utils.dom.parentNode(element)\n  }\n\n  return { action: null, interactable: null, element: null }\n}\n\nfunction prepare (\n  interaction: Interact.Interaction,\n  { action, interactable, element }: {\n    action: Interact.ActionProps\n    interactable: Interact.Interactable\n    element: Interact.Element\n  },\n  scope: Interact.Scope,\n) {\n  action = action || { name: null }\n\n  // clear previous target element cursor\n  if (interaction.interactable && interaction.interactable.options.styleCursor) {\n    setCursor(interaction.element, '', scope)\n  }\n\n  interaction.interactable = interactable\n  interaction.element = element\n  utils.copyAction(interaction.prepared, action)\n\n  interaction.rect = interactable && action.name\n    ? interactable.getRect(element)\n    : null\n\n  setInteractionCursor(interaction, scope)\n\n  scope.fire('autoStart:prepared', { interaction })\n}\n\nfunction withinInteractionLimit (interactable: Interact.Interactable, element: Interact.Element, action, scope: Interact.Scope) {\n  const options = interactable.options\n  const maxActions = options[action.name].max\n  const maxPerElement = options[action.name].maxPerElement\n  const autoStartMax = scope.autoStart.maxInteractions\n  let activeInteractions = 0\n  let interactableCount = 0\n  let elementCount = 0\n\n  // no actions if any of these values == 0\n  if (!(maxActions && maxPerElement && autoStartMax)) { return false }\n\n  for (const interaction of scope.interactions.list) {\n    const otherAction = interaction.prepared.name\n\n    if (!interaction.interacting()) { continue }\n\n    activeInteractions++\n\n    if (activeInteractions >= autoStartMax) {\n      return false\n    }\n\n    if (interaction.interactable !== interactable) { continue }\n\n    interactableCount += otherAction === action.name ? 1 : 0\n\n    if (interactableCount >= maxActions) {\n      return false\n    }\n\n    if (interaction.element === element) {\n      elementCount++\n\n      if (otherAction === action.name && elementCount >= maxPerElement) {\n        return false\n      }\n    }\n  }\n\n  return autoStartMax > 0\n}\n\nfunction maxInteractions (newValue, scope: Interact.Scope) {\n  if (utils.is.number(newValue)) {\n    scope.autoStart.maxInteractions = newValue\n\n    return this\n  }\n\n  return scope.autoStart.maxInteractions\n}\n\nfunction setCursor (element: Interact.Element, cursor, scope: Interact.Scope) {\n  if (scope.autoStart.cursorElement) {\n    scope.autoStart.cursorElement.style.cursor = ''\n  }\n\n  element.ownerDocument.documentElement.style.cursor = cursor\n  element.style.cursor = cursor\n  scope.autoStart.cursorElement = cursor ? element : null\n}\n\nfunction setInteractionCursor (interaction: Interact.Interaction, scope: Interact.Scope) {\n  const { interactable, element, prepared } = interaction\n\n  if (!(interaction.pointerType === 'mouse' && interactable && interactable.options.styleCursor)) {\n    return\n  }\n\n  let cursor = ''\n\n  if (prepared.name) {\n    const cursorChecker: Interact.CursorChecker = interactable.options[prepared.name].cursorChecker\n\n    if (utils.is.func(cursorChecker)) {\n      cursor = cursorChecker(prepared, interactable, element, interaction._interacting)\n    }\n    else {\n      cursor = scope.actions[prepared.name].getCursor(prepared)\n    }\n  }\n\n  setCursor(interaction.element, cursor || '', scope)\n}\n\nexport default {\n  id: 'auto-start/base',\n  install,\n  listeners: {\n    'interactions:down': prepareOnDown,\n    'interactions:move': (arg, scope) => {\n      prepareOnMove(arg, scope)\n      startOnMove(arg, scope)\n    },\n    'interactions:stop': clearCursorOnStop,\n  },\n  before: 'ations',\n  maxInteractions,\n  withinInteractionLimit,\n  validateAction,\n} as Interact.Plugin\n"
	]
}